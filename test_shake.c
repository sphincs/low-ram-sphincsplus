#include <stdio.h>
#include <string.h>
#include "fips202.h"
#include "test_sphincs.h"

/*
 * This tests out the SHAKE primitive
 *
 * Obvious question: why do we have a test for the SHAKE primitive?
 * Well, the main reason is that we have three different SHAKE implementations,
 * we want to make sure that they all perform the SHAKE-256 operation
 * correctly.
 * Now, we don't include any automated way to test all three - instead, we
 * ask the tester to go into tune.h and cycle TS_SHAKE256_OPT through the
 * three settings, and rebuild/retest for each setting.
 * This is a bit of a bother; however unless we update one of the
 * implementations, there really isn't a need for a thorough retest.
 */

/*
 * This goes through and exercises SHAKE by absorbing and squeezing out
 * different lengths.  This is probably overkill (as we don't have any
 * reason to suspect the blocking/deblocking logic), however we might as
 * well be thorough
 */
static int test( const unsigned char *expected_result,
	         unsigned len_expected_result,
                 const unsigned char *message,
                 unsigned len_message ) {
    SHAKE256_CTX ctx;

    for (unsigned n = 1; n <= len_message; n++) {
        ts_shake256_inc_init( &ctx );

        for (unsigned j=0; j<len_message; j+=n) {
            unsigned this_len = len_message - j;
            if (this_len > n) this_len = n;
            ts_shake256_inc_absorb( &ctx, &message[j], this_len );
        }

        ts_shake256_inc_finalize(&ctx);

        unsigned char actual_result[ 128 ] = { 0 };
	unsigned max_out_len = n;
        if (max_out_len > 128) max_out_len = 128;
	unsigned this_len;
        for (unsigned j=0; j<len_expected_result; j += this_len) {
	    this_len = len_expected_result - j;
	    if (this_len > max_out_len) this_len = max_out_len;
            ts_shake256_inc_squeeze(actual_result, this_len, &ctx);
            if (0 != memcmp( &expected_result[j], actual_result, this_len )) {
                printf( "   *** HASH MISMATCH\n" );
                return 0;
	    }
        }
    }

    return 1;
}

int test_shake256(int fast_flag, enum noise_level level) {
    (void)fast_flag;
    (void)level;

    /*
     * The below test vectors were extracted from NIST published values
     * Specifically, from SHA-3 XOF Test Vectors for Byte-Oriented Output
     * https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Algorithm-Validation-Program/documents/shs/shabytetestvectors.zip
     */
    {
        static unsigned char message[ 3 ] = { 0x21, 0xed, 0xa6 };
        static unsigned char output[] = {
            0xf7,0xd0,0x2b,0x45,0x12,0xbe,0x5d,0xdc,
	    0xc2,0x5d,0x14,0x8c,0x71,0x66,0x4d,0xfd,
	    0x34,0xe1,0x6a,0xbe,0xa2,0x6d,0x6e,0x72,
	    0x87,0xf4,0x5e,0x08,0xed,0x6f,0xcd,0x87,
        };
        if (!test( output, sizeof output, message, sizeof message )) return 0;
    }
    {
	/* Just under the rate size (LEN = 1080) */
        static unsigned char message[] = {
            0x36,0x2f,0x1e,0xb0,0x0b,0x37,0xa9,0x61,
            0x3b,0x1a,0xe8,0x2b,0x90,0x45,0x25,0x79,
            0xd4,0x2f,0x8b,0x1f,0x9e,0xde,0x95,0xf8,
            0x6b,0xad,0xc6,0xcd,0xf0,0x4c,0x9b,0x79,
            0xaf,0x08,0xbe,0x4b,0xc9,0x4d,0x7c,0xac,
            0x13,0x69,0x79,0x02,0x6b,0x92,0xa2,0xd4,
            0x4d,0x2b,0x64,0x2e,0xa1,0x43,0x1b,0x47,
            0xd7,0x5f,0xce,0x61,0x36,0x79,0x19,0xf1,
            0x71,0x48,0x6a,0x00,0x7c,0xc2,0x71,0xd1,
            0x9d,0xe0,0xd1,0xc4,0xc6,0xa1,0x1c,0x7a,
            0x22,0x51,0xfe,0x3a,0xee,0x0b,0xb8,0x93,
            0x8a,0x7d,0xd0,0x43,0xd0,0xeb,0x07,0x58,
            0xa4,0x76,0x8c,0x95,0xcc,0x9f,0x6f,0x17,
            0x03,0x07,0x58,0x39,0x48,0x78,0x79,0xb4,
            0x7c,0x29,0xc1,0x0b,0x2c,0x3e,0x53,0x26,
            0xac,0x8f,0x36,0x3c,0x65,0xaa,0x4e,0xf7,
            0x6f,0x1b,0x8b,0xd3,0x63,0xeb,0x60
	};
        static unsigned char output[] = {
            0xc6,0xce,0x60,0xc1,0x85,0x2e,0xa7,0x80,
            0xed,0x84,0x5a,0xac,0x4c,0xa6,0xa3,0x0e,
            0x09,0xf5,0xc0,0x06,0x4c,0x96,0x75,0x86,
            0x51,0x78,0x71,0x7c,0xfe,0xb1,0xdc,0x97,
        };
        if (!test( output, sizeof output, message, sizeof message )) return 0;
    }
    {
	/* Exactly the rate size (LEN = 1088) */
        static unsigned char message[] = {
            0xd8,0xf1,0x2b,0x97,0xf8,0x1d,0x47,0xae,
            0xbb,0xfb,0x73,0x14,0xff,0x04,0x17,0x2c,
            0xf2,0xbe,0x71,0xc3,0x77,0x8e,0x23,0x8b,
            0xcc,0xcd,0xee,0xcb,0x69,0x1f,0xbd,0x54,
            0x2b,0x00,0xe5,0xb7,0xb1,0xa0,0xab,0xb5,
            0x07,0xf1,0x07,0xf7,0x81,0xfe,0xa7,0x00,
            0xea,0x7e,0x37,0x5f,0xde,0xa9,0xe0,0x29,
            0x75,0x4a,0x0e,0xa6,0x22,0x16,0x77,0x4b,
            0xda,0x3c,0x59,0xe8,0x78,0x3d,0x02,0x23,
            0x60,0xfe,0x96,0x25,0x62,0x1c,0x0d,0x93,
            0xe2,0x7f,0x7b,0xc0,0x36,0x32,0x94,0x21,
            0x50,0x71,0x6f,0x01,0x9d,0x04,0x8a,0x75,
            0x2c,0xcc,0x0f,0x93,0x13,0x9c,0x55,0xdf,
            0x0f,0x4a,0xaa,0x06,0x6a,0x05,0x50,0xcf,
            0x22,0xe8,0xc5,0x4e,0x47,0xd0,0x47,0x5b,
            0xa5,0x6b,0x98,0x42,0xa3,0x92,0xff,0xbc,
            0x6b,0xd9,0x8f,0x1e,0x4b,0x64,0xab,0xd1,
	};
        static unsigned char output[] = {
            0xe2,0xe1,0xc4,0x32,0xdd,0x07,0xc2,0xee,
            0x89,0xa7,0x8f,0x31,0x21,0x1c,0x92,0xee,
            0xb5,0x30,0x6c,0x4f,0xa4,0xdb,0x93,0xc4,
            0xe5,0xcd,0x43,0x08,0x0d,0x60,0x79,0xe4,
        };
        if (!test( output, sizeof output, message, sizeof message )) return 0;
    }
    {
	/* One more than the rate size (LEN = 1096) */
        static unsigned char message[] = {
            0xa1,0x0d,0x05,0xd7,0xe5,0x1e,0x75,0xdc,
            0x15,0x0f,0x64,0x0e,0xc4,0x72,0x28,0x37,
            0x22,0x0b,0x86,0xdf,0x2a,0x35,0x80,0xca,
            0x1c,0x82,0x6e,0xc2,0x2e,0xa2,0x50,0x97,
            0x7e,0x86,0x63,0x63,0x4c,0xc4,0xf2,0x12,
            0x66,0x3e,0x6f,0x22,0xe3,0xff,0xc2,0xa8,
            0x14,0x65,0xe1,0x94,0xb8,0x85,0xa1,0x35,
            0x6f,0xcb,0xcc,0x00,0x72,0xe1,0x73,0x8d,
            0x80,0xd2,0x85,0xe2,0x1c,0x70,0xa1,0xf4,
            0xf5,0xf3,0x29,0x6b,0xa6,0xe2,0x98,0xa6,
            0x9f,0x37,0x15,0xff,0x63,0xbe,0x48,0x50,
            0xf5,0xbe,0x6c,0xb6,0x8c,0xdb,0xa5,0x94,
            0x8e,0x3b,0x94,0xdb,0xbc,0xe8,0x29,0x89,
            0xaa,0x75,0xb9,0x70,0x73,0xe5,0x51,0x39,
            0xaa,0xc8,0x49,0xa8,0x94,0xa7,0x1c,0x22,
            0x94,0xa2,0x77,0x6c,0xe6,0x58,0x8f,0xb5,
            0x90,0x07,0xb8,0xd7,0x96,0xf4,0x34,0xda,
            0x6e,
	};
        static unsigned char output[] = {
            0x02,0xf1,0x7b,0xf8,0x6d,0xc7,0xb7,0xf9,
            0xc3,0xfb,0x96,0xe4,0xb3,0xa1,0x0c,0xa5,
            0x74,0xcd,0x0f,0x8d,0xed,0xda,0x50,0xf3,
            0xdd,0xa8,0x00,0x8c,0xe9,0xe8,0xfe,0xc9,
        };
        if (!test( output, sizeof output, message, sizeof message )) return 0;
    }
    {
	/* And try it with an output that goes past the rate (OutputLen = 1112 */
        static unsigned char message[] = {
            0x8d,0x80,0x01,0xe2,0xc0,0x96,0xf1,0xb8,
            0x8e,0x7c,0x92,0x24,0xa0,0x86,0xef,0xd4,
            0x79,0x7f,0xbf,0x74,0xa8,0x03,0x3a,0x2d,
            0x42,0x2a,0x2b,0x6b,0x8f,0x67,0x47,0xe4,
	};
        static unsigned char output[] = {
            0x2e,0x97,0x5f,0x6a,0x8a,0x14,0xf0,0x70,
            0x4d,0x51,0xb1,0x36,0x67,0xd8,0x19,0x5c,
            0x21,0x9f,0x71,0xe6,0x34,0x56,0x96,0xc4,
            0x9f,0xa4,0xb9,0xd0,0x8e,0x92,0x25,0xd3,
            0xd3,0x93,0x93,0x42,0x51,0x52,0xc9,0x7e,
            0x71,0xdd,0x24,0x60,0x1c,0x11,0xab,0xcf,
            0xa0,0xf1,0x2f,0x53,0xc6,0x80,0xbd,0x3a,
            0xe7,0x57,0xb8,0x13,0x4a,0x9c,0x10,0xd4,
            0x29,0x61,0x58,0x69,0x21,0x7f,0xdd,0x58,
            0x85,0xc4,0xdb,0x17,0x49,0x85,0x70,0x3a,
            0x6d,0x6d,0xe9,0x4a,0x66,0x7e,0xac,0x30,
            0x23,0x44,0x3a,0x83,0x37,0xae,0x1b,0xc6,
            0x01,0xb7,0x6d,0x7d,0x38,0xec,0x3c,0x34,
            0x46,0x31,0x05,0xf0,0xd3,0x94,0x9d,0x78,
            0xe5,0x62,0xa0,0x39,0xe4,0x46,0x95,0x48,
            0xb6,0x09,0x39,0x5d,0xe5,0xa4,0xfd,0x43,
            0xc4,0x6c,0xa9,0xfd,0x6e,0xe2,0x9a,0xda,
            0x5e,0xfc,0x07,
        };
        if (!test( output, sizeof output, message, sizeof message )) return 0;
    }

    return 1;
}
